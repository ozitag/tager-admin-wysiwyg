diff --git a/node_modules/@ckeditor/ckeditor5-ui/src/panel/sticky/stickypanelview.js b/node_modules/@ckeditor/ckeditor5-ui/src/panel/sticky/stickypanelview.js
index c5488fb..06a3acf 100644
--- a/node_modules/@ckeditor/ckeditor5-ui/src/panel/sticky/stickypanelview.js
+++ b/node_modules/@ckeditor/ckeditor5-ui/src/panel/sticky/stickypanelview.js
@@ -16,6 +16,44 @@ import '../../../theme/components/panel/stickypanel.css';
 
 const toPx = toUnit( 'px' );
 
+function getComputedStyleProp( element, prop ) {
+	return global.window.getComputedStyle( element ).getPropertyValue( prop );
+}
+
+function isElementScrollableVertically( element ) {
+	const overflowValue = getComputedStyleProp( element, 'overflow-y' );
+	return (overflowValue === 'auto' || overflowValue === 'scroll');
+}
+
+function findScrollableContainer( element ) {
+	let currentParent = element.parentElement;
+
+	while ( currentParent ) {
+		if ( isElementScrollableVertically( currentParent ) ) {
+			return currentParent;
+		}
+
+		currentParent = currentParent.parentElement;
+	}
+
+	return null;
+}
+
+function findAllScrollableParents(element) {
+	const scrollableParents = [];
+
+	let currentScrollableParent = findScrollableContainer(element);
+
+	while(currentScrollableParent) {
+		scrollableParents.push(currentScrollableParent);
+		currentScrollableParent = findScrollableContainer(currentScrollableParent)
+	}
+
+	scrollableParents.push(global.window);
+
+	return scrollableParents;
+}
+
 /**
  * The sticky panel view class.
  */
@@ -27,6 +65,7 @@ export default class StickyPanelView extends View {
 		super( locale );
 
 		const bind = this.bindTemplate;
+		this.shouldUseCustomSticky = Boolean(this.getCustomStickyPanelBoundsElement());
 
 		/**
 		 * Controls whether the sticky panel should be active.
@@ -91,6 +130,16 @@ export default class StickyPanelView extends View {
 		 */
 		this.set( 'viewportTopOffset', 0 );
 
+		/**
+		 * CUSTOM
+		 *
+		 * @protected
+		 * @readonly
+		 * @observable
+		 * @member {Number | null} #_customViewportTopOffset
+		 */
+		this.set( '_customViewportTopOffset', null);
+
 		/**
 		 * Controls the `margin-left` CSS style of the panel.
 		 *
@@ -193,9 +242,13 @@ export default class StickyPanelView extends View {
 						return isSticky ? toPx( this._contentPanelPlaceholder.getBoundingClientRect().width ) : null;
 					} ),
 
-					top: bind.to( '_hasViewportTopOffset', _hasViewportTopOffset => {
-						return _hasViewportTopOffset ? toPx( this.viewportTopOffset ) : null;
-					} ),
+					top: this.shouldUseCustomSticky
+						? bind.to( '_customViewportTopOffset', _customViewportTopOffset => {
+							return typeof _customViewportTopOffset === 'number' ? toPx( this._customViewportTopOffset ) : null;
+						} )
+						: bind.to( '_hasViewportTopOffset', _hasViewportTopOffset => {
+							return _hasViewportTopOffset ? toPx( this.viewportTopOffset ) : null;
+						} ),
 
 					bottom: bind.to( '_isStickyToTheLimiter', _isStickyToTheLimiter => {
 						return _isStickyToTheLimiter ? toPx( this.limiterBottomOffset ) : null;
@@ -223,6 +276,10 @@ export default class StickyPanelView extends View {
 		} );
 	}
 
+	getCustomStickyPanelBoundsElement() {
+		return document.querySelector('[data-sticky-panel-limiter]');
+	}
+
 	/**
 	 * @inheritDoc
 	 */
@@ -232,10 +289,19 @@ export default class StickyPanelView extends View {
 		// Check if the panel should go into the sticky state immediately.
 		this._checkIfShouldBeSticky();
 
-		// Update sticky state of the panel as the window is being scrolled.
-		this.listenTo( global.window, 'scroll', () => {
-			this._checkIfShouldBeSticky();
-		} );
+		if (this.shouldUseCustomSticky) {
+			global.window.requestAnimationFrame(() => {
+				findAllScrollableParents(this._contentPanel).forEach(scrollableContainer => {
+					this.listenTo( scrollableContainer, 'scroll', () => {
+						this._checkIfShouldBeSticky();
+					} );
+				});
+			})
+		} else {
+			this.listenTo( global.window, 'scroll', () => {
+				this._checkIfShouldBeSticky();
+			} );
+		}
 
 		// Synchronize with `model.isActive` because sticking an inactive panel is pointless.
 		this.listenTo( this, 'change:isActive', () => {
@@ -243,6 +309,33 @@ export default class StickyPanelView extends View {
 		} );
 	}
 
+	_checkIfShouldBeStickyCustom() {
+		const panelRect = this._panelRect = this._contentPanel.getBoundingClientRect();
+
+		const scrollableContainer = this.getCustomStickyPanelBoundsElement();
+		const scrollRect = scrollableContainer.getBoundingClientRect();
+
+		const minimalBottomOffset = this._panelRect.height  + this.limiterBottomOffset;
+
+		let limiterRect;
+
+		if ( !this.limiterElement ) {
+			this.isSticky = false;
+		} else {
+			limiterRect = this._limiterRect = this.limiterElement.getBoundingClientRect();
+
+			this.isSticky = this.isActive
+				&& ((limiterRect.top < scrollRect.top) || (limiterRect.top < 0 && scrollRect.top < 0))
+				&& limiterRect.bottom - scrollRect.top > minimalBottomOffset
+				&& limiterRect.bottom > minimalBottomOffset
+				&& scrollRect.bottom > minimalBottomOffset
+				&& !(limiterRect.top > 0 && limiterRect.top > scrollRect.top && panelRect.top < limiterRect.top);
+		}
+
+		const customViewportTopOffset = scrollRect.top < 0 ? 0 : scrollRect.top;
+		this.set( '_customViewportTopOffset', this.isSticky ? customViewportTopOffset : null );
+	}
+
 	/**
 	 * Analyzes the environment to decide whether the panel should
 	 * be sticky or not.
@@ -250,6 +343,11 @@ export default class StickyPanelView extends View {
 	 * @protected
 	 */
 	_checkIfShouldBeSticky() {
+		if (this.shouldUseCustomSticky) {
+			this._checkIfShouldBeStickyCustom();
+			return;
+		}
+
 		const panelRect = this._panelRect = this._contentPanel.getBoundingClientRect();
 		let limiterRect;
 
